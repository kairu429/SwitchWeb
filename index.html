<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>SwitchÈ¢® Web„É©„É≥„ÉÅ„É£„Éº ‚Äî ÁßªÂãïÔºàÈö£ÂÖ•„ÇåÊõø„Åà & „Éõ„Éº„É´„ÉâÂ∑ÆËæºÔºâÂØæÂøú</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg1:#0d0d0d;
      --bg2:#1a1a1a;
      --accent:#00bfff;
      --icon-size:140px;
      --gap:50px;
      --circle-size:64px;
    }
    html,body{height:100%;margin:0;}
    body{
      background: linear-gradient(180deg,var(--bg1),var(--bg2));
      color:#fff;
      font-family:"Segoe UI", system-ui, -apple-system, "Helvetica Neue", Arial;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .topbar{display:flex;align-items:center;justify-content:flex-end;padding:10px 24px;color:#cfcfcf;gap:12px;}
    .status-right{display:flex; gap:14px; align-items:center; color:#bfbfbf;}

    .launcher-wrap{position:relative; flex:1; display:flex; align-items:center; justify-content:center; overflow:hidden;}
    .launcher{
      display:flex; align-items:center; overflow-x:auto; gap:var(--gap); padding:20px 80px;
      scrollbar-width:none; -ms-overflow-style:none;
    }
    .launcher::-webkit-scrollbar{display:none;}

    .app{
      position:relative; width:var(--icon-size); display:flex; flex-direction:column; align-items:center;
      justify-content:flex-start; flex-shrink:0; gap:8px; transition:transform .12s ease;
      touch-action: manipulation;
      user-select:none;
    }
    .app-name{
      margin:0; padding:0 6px; font-size:14.5px; font-weight:700; color:var(--accent);
      white-space:nowrap; text-overflow:ellipsis; overflow:hidden; max-width:calc(var(--icon-size)+20px);
      opacity:0; transform:translateY(-4px); transition:opacity .12s ease, transform .12s ease; pointer-events:none;
    }

    .icon{
      width:var(--icon-size); height:var(--icon-size); border-radius:18px; background:#222;
      display:flex; align-items:center; justify-content:center; overflow:hidden;
      box-shadow:0 6px 18px rgba(0,0,0,0.45); transition:box-shadow .12s ease, border .12s ease, transform .12s ease; position:relative; z-index:1;
      font-weight:700; color:#fff;
    }
    .icon img{width:100%;height:100%;object-fit:cover;display:block;border-radius:18px;}

    .app.selected .app-name{opacity:1; transform:translateY(0);}
    .app.selected .icon{
      border:3px solid rgba(0,191,255,0.95);
      box-shadow:0 8px 30px rgba(0,191,255,0.18), 0 4px 10px rgba(0,0,0,0.35);
    }

    .launcher.compact .app:not(.selected){ transform: translateX(-8px); }

    .delete-btn{
      position:absolute; top:-10px; right:-10px; width:26px; height:26px; border-radius:50%;
      border:none; background:#ff5c5c; color:#fff; cursor:pointer; display:none; font-weight:700;
      box-shadow:0 2px 6px rgba(0,0,0,0.4); z-index:2;
    }
    .app:hover .delete-btn{ display:block; }

    /* drag / hold visual */
    .app.dragging { transform: scale(1.04); opacity:0.95; box-shadow:0 12px 26px rgba(0,0,0,0.5); }
    .app.hold-source { outline: 3px dashed rgba(0,191,255,0.5); outline-offset:6px; }

    /* ‰∏∏„Ç¢„Ç§„Ç≥„É≥„É°„Éã„É•„Éº */
    .menu{ display:flex; justify-content:center; align-items:center; gap:40px; padding:18px 12px;
      border-top:1px solid rgba(255,255,255,0.04);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); }
    .circle-item{ display:flex; flex-direction:column; align-items:center; gap:8px; }
    .circle-btn{
      width:var(--circle-size); height:var(--circle-size); border-radius:50%;
      background:rgba(255,255,255,0.04); display:flex; align-items:center; justify-content:center;
      border:2px solid rgba(255,255,255,0.06); cursor:pointer; transition:background .12s ease, transform .12s ease, box-shadow .12s ease;
      color:#fff; font-weight:700; outline:none; touch-action: manipulation;
    }
    .circle-btn.selected{ border-color:var(--accent); box-shadow:0 0 0 6px rgba(0,191,255,0.18); transform:translateY(-3px); background:rgba(0,191,255,0.06); }
    .circle-label{ font-size:13px; color:#ddd; text-align:center; user-select:none; }

    @media (max-width:900px){ :root{ --icon-size:120px; --gap:34px; --circle-size:54px; } }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="status-right">
      <div id="time"></div>
      <div id="battery">üîã --%</div>
    </div>
  </div>

  <div class="launcher-wrap">
    <div class="launcher" id="launcher" role="listbox" aria-label="„Ç¢„Éó„É™„É©„É≥„ÉÅ„É£„Éº">
      <!-- „Éá„Éï„Ç©„É´„ÉàÔºà„ÇØ„ÉÉ„Ç≠„Éº„Åå„ÅÇ„Çå„Å∞‰∏äÊõ∏„ÅçÔºâ -->
      <div class="app selected" data-url="https://www.google.com" role="option" aria-selected="true">
        <div class="app-name">Google</div>
        <div class="icon"><img src="https://www.google.com/favicon.ico" alt="Google"></div>
        <button class="delete-btn" title="ÂâäÈô§">√ó</button>
      </div>

      <div class="app" data-url="https://www.youtube.com" role="option" aria-selected="false">
        <div class="app-name">YouTube</div>
        <div class="icon"><img src="https://www.youtube.com/favicon.ico" alt="YouTube"></div>
        <button class="delete-btn" title="ÂâäÈô§">√ó</button>
      </div>

      <div class="app" data-url="https://discord.com" role="option" aria-selected="false">
        <div class="app-name">Discord</div>
        <div class="icon"><img src="https://discord.com/favicon.ico" alt="Discord"></div>
        <button class="delete-btn" title="ÂâäÈô§">√ó</button>
      </div>

      <div class="app" data-url="https://github.com" role="option" aria-selected="false">
        <div class="app-name">GitHub</div>
        <div class="icon"><img src="https://github.com/favicon.ico" alt="GitHub"></div>
        <button class="delete-btn" title="ÂâäÈô§">√ó</button>
      </div>

      <!-- ËøΩÂä†„Éú„Çø„É≥ -->
      <div class="app" id="add-app" role="option" aria-selected="false">
        <div class="app-name">ËøΩÂä†</div>
        <div class="icon">Ôºã</div>
      </div>
    </div>
  </div>

  <div class="menu" role="toolbar" aria-label="„É©„É≥„ÉÅ„É£„Éº„É°„Éã„É•„Éº">
    <div class="circle-item">
      <button class="circle-btn" id="btn-settings" title="Ë®≠ÂÆö" aria-label="Ë®≠ÂÆö">‚öô</button>
      <div class="circle-label">Ë®≠ÂÆö</div>
    </div>

    <div class="circle-item">
      <button class="circle-btn" id="btn-store" title="„Çπ„Éà„Ç¢" aria-label="„Çπ„Éà„Ç¢">üõí</button>
      <div class="circle-label">„Çπ„Éà„Ç¢</div>
    </div>

    <div class="circle-item">
      <button class="circle-btn" id="btn-power" title="ÈõªÊ∫ê" aria-label="ÈõªÊ∫ê">‚èª</button>
      <div class="circle-label">ÈõªÊ∫ê</div>
    </div>
  </div>

  <script>
    /******************** Ë®≠ÂÆö ********************/
    const HOLD_THRESHOLD = 300; // ms : Ê±∫ÂÆöÈï∑Êäº„Åó„ÇÑ„Éù„Ç§„É≥„ÇøÈï∑Êäº„ÅóÂà§ÂÆö
    /***********************************************/

    /* ---------------- Cookie utilities ---------------- */
    function setCookie(name, value, days) {
      const expires = new Date(Date.now() + days*864e5).toUTCString();
      document.cookie = name + '=' + value + '; expires=' + expires + '; path=/; SameSite=Lax';
    }
    function getCookie(name) {
      return document.cookie.split('; ').reduce((r, v) => {
        const parts = v.split('=');
        return parts[0] === name ? parts.slice(1).join('=') : r;
      }, '');
    }

    function saveAppsToCookie() {
      try {
        const list = [];
        Array.from(launcher.querySelectorAll('.app')).forEach(appEl => {
          if (appEl.id === 'add-app') return;
          const nameEl = appEl.querySelector('.app-name');
          const name = nameEl ? nameEl.textContent : '';
          const url = appEl.dataset.url || '';
          list.push({name, url});
        });
        const json = encodeURIComponent(JSON.stringify(list));
        setCookie('switch_launcher_apps', json, 365);
      } catch (e) {
        console.error('saveAppsToCookie error', e);
      }
    }

    function loadAppsFromCookie() {
      const raw = getCookie('switch_launcher_apps');
      if (!raw) return false;
      try {
        const arr = JSON.parse(decodeURIComponent(raw));
        if (!Array.isArray(arr)) return false;
        // remove existing apps except add-app
        const current = Array.from(launcher.querySelectorAll('.app'));
        current.forEach(el => { if (el.id !== 'add-app') el.remove(); });
        // insert from cookie
        arr.forEach(entry => {
          if (!entry || !entry.url) return;
          const newEl = createAppElement(entry.name || entry.url, entry.url);
          launcher.insertBefore(newEl, addAppEl);
        });
        bindAppPointerHandlers(addAppEl);
        return true;
      } catch (e) {
        console.error('loadAppsFromCookie parse error', e);
        return false;
      }
    }

    /* ---------------- elements & state ---------------- */
    const launcher = document.getElementById('launcher');
    const addAppEl = document.getElementById('add-app');
    const circleBtns = [...document.querySelectorAll('.circle-btn')];

    let selectedIndex = 0;
    let circleIndex = -1;
    const apps = () => Array.from(launcher.querySelectorAll('.app'));

    let lastInput = 0;
    const INPUT_COOLDOWN = 120;

    // gamepad
    let gpPrevButtons = new Array(20).fill(false);
    let gpPrevAxes = [0,0];

    function now(){ return performance.now(); }
    function canInput() {
      const t = now();
      if (t - lastInput < INPUT_COOLDOWN) return false;
      lastInput = t;
      return true;
    }

    /* ---------------- helpers ---------------- */
    function normalizeUrl(input){
      if (!input) return null;
      try { const u = new URL(input); return u.href; }
      catch (e) {
        try { const u2 = new URL('https://' + input); return u2.href; }
        catch (e2) { return null; }
      }
    }

    function faviconFor(url){
      try { const u = new URL(url); return u.origin + '/favicon.ico'; }
      catch (e){ return ''; }
    }

    function createIconContent(name, faviconSrc){
      const icon = document.createElement('div');
      icon.className = 'icon';
      if (faviconSrc) {
        const img = document.createElement('img');
        img.src = faviconSrc;
        img.alt = name;
        img.onerror = () => {
          icon.innerHTML = '';
          const txt = document.createElement('div');
          txt.textContent = (name && name[0]) ? name[0].toUpperCase() : '‚Ä¢';
          txt.style.fontSize = '48px';
          txt.style.fontWeight = '700';
          icon.appendChild(txt);
        };
        icon.appendChild(img);
      } else {
        const txt = document.createElement('div');
        txt.textContent = (name && name[0]) ? name[0].toUpperCase() : '‚Ä¢';
        txt.style.fontSize = '48px';
        txt.style.fontWeight = '700';
        icon.appendChild(txt);
      }
      return icon;
    }

    /* ---------------- create/bind apps ---------------- */
    function bindAppPointerHandlers(appEl){
      // pointer long-press => Èö£ÂÖ•„ÇåÊõø„Åà„Éâ„É©„ÉÉ„Ç∞
      let longPressTimer = null;
      let pointerDragState = null;

      appEl.addEventListener('pointerdown', (ev) => {
        const idx = apps().indexOf(appEl);
        if (idx < 0) return;
        // select immediately
        selectedIndex = idx;
        circleIndex = -1;
        updateSelectionUI();

        // start long-press timer to trigger swap-drag
        longPressTimer = setTimeout(() => {
          startPointerSwapDrag(ev, idx);
          longPressTimer = null;
        }, HOLD_THRESHOLD);

        // store pointer id for later (so pointerup clears)
        pointerDragState = { pointerId: ev.pointerId, moved: false };
      }, {passive:true});

      // cancel longpress on pointerup/cancel/leave before threshold
      ['pointerup','pointercancel','pointerleave'].forEach(evname => {
        appEl.addEventListener(evname, (ev) => {
          if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
        }, {passive:true});
      });

      // normal click/dbl handled elsewhere
    }

    function createAppElement(name, url){
      const el = document.createElement('div');
      el.className = 'app';
      el.dataset.url = url;
      el.setAttribute('role','option');
      el.setAttribute('aria-selected','false');

      const nameEl = document.createElement('div');
      nameEl.className = 'app-name';
      nameEl.textContent = name;

      const iconWrapper = createIconContent(name, faviconFor(url));

      const delBtn = document.createElement('button');
      delBtn.className = 'delete-btn';
      delBtn.title = 'ÂâäÈô§';
      delBtn.textContent = '√ó';

      delBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const idx = apps().indexOf(el);
        el.remove();
        if (selectedIndex >= apps().length) selectedIndex = apps().length - 1;
        if (selectedIndex < 0) selectedIndex = 0;
        updateSelectionUI();
        saveAppsToCookie();
      });

      el.appendChild(nameEl);
      el.appendChild(iconWrapper);
      el.appendChild(delBtn);

      bindAppPointerHandlers(el);
      return el;
    }

    /* ---------------- UI update ---------------- */
    function updateSelectionUI(){
      apps().forEach((appEl, i) => {
        const isSelected = (circleIndex === -1 && i === selectedIndex);
        appEl.classList.toggle('selected', isSelected);
        appEl.setAttribute('aria-selected', isSelected ? 'true' : 'false');
        const nn = appEl.querySelector('.app-name');
        if (nn) {
          nn.style.opacity = isSelected ? '1' : '0';
          nn.style.transform = isSelected ? 'translateY(0)' : 'translateY(-4px)';
        }
      });
      circleBtns.forEach((btn, i) => btn.classList.toggle('selected', i === circleIndex));
      launcher.classList.toggle('compact', true);
      if (circleIndex === -1) scrollSelectedIntoView();
    }

    function scrollSelectedIntoView(){
      const sel = apps()[selectedIndex];
      if (!sel) return;
      const lr = launcher.getBoundingClientRect();
      const sr = sel.getBoundingClientRect();
      const offset = (sr.left + sr.right) / 2 - (lr.left + lr.right) / 2;
      launcher.scrollBy({ left: offset, behavior: 'smooth' });
    }

    /* ---------------- navigation actions ---------------- */
    function moveApp(delta){
      if (!canInput()) return;
      const len = apps().length;
      if (len === 0) return;
      selectedIndex = (selectedIndex + delta + len) % len;
      updateSelectionUI();
    }
    function moveCircle(delta){
      if (!canInput()) return;
      const len = circleBtns.length;
      circleIndex = (circleIndex + delta + len) % len;
      updateSelectionUI();
    }
    function switchToCircle(index = 0){
      if (!canInput()) return;
      circleIndex = Math.max(0, Math.min(index, circleBtns.length - 1));
      updateSelectionUI();
    }
    function switchToApps(){
      if (!canInput()) return;
      circleIndex = -1;
      updateSelectionUI();
    }

    function deleteSelectedApp(){
      if (circleIndex !== -1) return;
      const a = apps()[selectedIndex];
      if (a && a.id !== 'add-app') {
        a.remove();
        if (selectedIndex >= apps().length) selectedIndex = apps().length - 1;
        if (selectedIndex < 0) selectedIndex = 0;
        updateSelectionUI();
        saveAppsToCookie();
      }
    }

    function openSelected(){
      if (circleIndex === -1){
        const a = apps()[selectedIndex];
        if (!a) return;
        if (a.id === 'add-app'){
          openAddDialog();
        } else {
          const url = a.dataset.url;
          if (url) window.open(url, '_blank');
        }
      } else {
        if (circleIndex >= 0 && circleIndex < circleBtns.length) circleBtns[circleIndex].click();
      }
    }

    /* ---------------- Add dialog ---------------- */
    function openAddDialog(){
      const name = prompt('„Ç¢„Éó„É™Âêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:');
      if (!name) return;
      let urlInput = prompt('URL„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ: (‰æã: example.com „Åæ„Åü„ÅØ https://example.com)');
      if (!urlInput) return;
      const normalized = normalizeUrl(urlInput);
      if (!normalized) {
        alert('ÁÑ°Âäπ„Å™URL„Åß„Åô„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶Ë©¶„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        return;
      }
      const newEl = createAppElement(name, normalized);
      launcher.insertBefore(newEl, addAppEl);
      selectedIndex = apps().indexOf(newEl);
      circleIndex = -1;
      updateSelectionUI();
      saveAppsToCookie();
    }

    addAppEl.addEventListener('click', (e) => {
      e.stopPropagation();
      const idx = apps().indexOf(addAppEl);
      if (idx >= 0) { selectedIndex = idx; circleIndex = -1; updateSelectionUI(); }
      openAddDialog();
    });

    /* ---------------- „Éû„Ç¶„Çπ: Âè≥„ÇØ„É™„ÉÉ„ÇØÂâäÈô§ÔºàÊó¢Â≠òÔºâ ---------------- */
    launcher.addEventListener('contextmenu', (e) => {
      const app = e.target.closest('.app');
      if (!app) return;
      e.preventDefault();
      if (app.id === 'add-app') return;
      app.remove();
      if (selectedIndex >= apps().length) selectedIndex = apps().length - 1;
      if (selectedIndex < 0) selectedIndex = 0;
      updateSelectionUI();
      saveAppsToCookie();
    });

    /* ---------------- pointer-swap-dragÔºàÈï∑Êäº„Åó„ÅßÈö£ÂÖ•„ÇåÊõø„ÅàÔºâ ---------------- */
    let pointerActiveDrag = null;
    function startPointerSwapDrag(ev, startIndex){
      // start drag swap mode for pointer operations (Èö£ÂÖ•„ÇåÊõø„Åà)
      const current = apps()[startIndex];
      if (!current || current.id === 'add-app') return;
      current.classList.add('dragging');
      pointerActiveDrag = { pointerId: ev.pointerId, currentIndex: startIndex };

      function onMove(e){
        if (!pointerActiveDrag) return;
        if (e.pointerId !== pointerActiveDrag.pointerId) return;
        const x = e.clientX;
        const curIdx = pointerActiveDrag.currentIndex;
        const right = apps()[curIdx+1];
        const left = apps()[curIdx-1];
        if (right) {
          const rrect = right.getBoundingClientRect();
          const rcenter = rrect.left + rrect.width/2;
          if (x > rcenter) {
            // swap current with right (move right before current => right becomes left of current)
            const curEl = apps()[curIdx];
            const rightEl = apps()[curIdx+1];
            launcher.insertBefore(rightEl, curEl);
            // update index (current moved to curIdx+1)
            pointerActiveDrag.currentIndex = apps().indexOf(curEl);
            updateSelectionUI();
          }
        }
        if (left) {
          const lrect = left.getBoundingClientRect();
          const lcenter = lrect.left + lrect.width/2;
          if (x < lcenter) {
            // swap current left by inserting current before left
            const curEl = apps()[pointerActiveDrag.currentIndex];
            const leftEl = apps()[pointerActiveDrag.currentIndex-1];
            if (leftEl) launcher.insertBefore(curEl, leftEl);
            pointerActiveDrag.currentIndex = apps().indexOf(curEl);
            updateSelectionUI();
          }
        }
      }

      function onUp(e){
        if (!pointerActiveDrag) return;
        if (e.pointerId !== pointerActiveDrag.pointerId) return;
        // end drag
        const curEl = apps()[pointerActiveDrag.currentIndex];
        if (curEl) curEl.classList.remove('dragging');
        pointerActiveDrag = null;
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
        saveAppsToCookie();
      }

      window.addEventListener('pointermove', onMove, {passive:true});
      window.addEventListener('pointerup', onUp, {passive:true});
    }

    /* ---------------- hold-mode (Ê±∫ÂÆö„ÇíÊäº„Åó„Å™„Åå„ÇâÁßªÂãï -> „É™„É™„Éº„Çπ„ÅßÂ∑Æ„ÅóËæº„Åø) ---------------- */
    let holdMode = {
      active: false,
      sourceIndex: null,
      timer: null,
      initiatedBy: null // 'key' | 'gamepad' | 'pointer'
    };

    function startHoldMode(sourceIndex, initiatedBy){
      if (holdMode.active) return;
      const src = apps()[sourceIndex];
      if (!src || src.id === 'add-app') return;
      holdMode.active = true;
      holdMode.sourceIndex = sourceIndex;
      holdMode.initiatedBy = initiatedBy || 'key';
      src.classList.add('hold-source');
      // keep selection on current (target) item
      updateSelectionUI();
    }

    function endHoldModeCommit(){
      if (!holdMode.active) return;
      const sourceIndex = holdMode.sourceIndex;
      const targetIndex = selectedIndex;
      const sourceEl = apps()[sourceIndex];
      if (!sourceEl) { cancelHoldMode(); return; }
      // compute insertion index after removal:
      // if sourceIndex < targetIndex => insertionIndex = targetIndex - 1 after removal
      // else insertionIndex = targetIndex
      // remove source first
      sourceEl.classList.remove('hold-source');
      const sourceNode = sourceEl;
      // store label or node
      // remove it
      // note: we use apps() to reflect current DOM
      // to avoid messing up indices, compute insertionIndex as:
      let insertionIndex = targetIndex - (sourceIndex < targetIndex ? 1 : 0);
      sourceNode.remove();
      const nodesNow = apps();
      if (insertionIndex < 0) insertionIndex = 0;
      if (insertionIndex >= nodesNow.length) {
        // append before add-app (which is last). nodesNow excludes add-app; but our apps() includes add-app.
        // We want to insert before add-app element, so find add-app and insert before it.
        const add = addAppEl;
        launcher.insertBefore(sourceNode, add);
      } else {
        const beforeNode = nodesNow[insertionIndex];
        launcher.insertBefore(sourceNode, beforeNode);
      }
      // update selection to indicate moved item
      selectedIndex = apps().indexOf(sourceNode);
      updateSelectionUI();
      saveAppsToCookie();
      holdMode.active = false;
      holdMode.sourceIndex = null;
      holdMode.initiatedBy = null;
    }

    function cancelHoldMode(){
      if (!holdMode.active) return;
      const src = apps()[holdMode.sourceIndex];
      if (src) src.classList.remove('hold-source');
      holdMode.active = false;
      holdMode.sourceIndex = null;
      holdMode.initiatedBy = null;
      updateSelectionUI();
    }

    /* ---------------- keyboard: Enter Èï∑Êäº„ÅóÔºàhold-modeÔºâ/ Áü¢Âç∞„ÅßÁßªÂãï ---------------- */
    let keyHoldTimer = null;
    let enterDown = false;
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (enterDown) return;
        enterDown = true;
        // start hold timer
        keyHoldTimer = setTimeout(() => {
          // enter held -> start hold mode for selectedIndex
          startHoldMode(selectedIndex, 'key');
          keyHoldTimer = null;
        }, HOLD_THRESHOLD);
      } else {
        // navigation handling differs when in hold-mode vs normal
        if (!holdMode.active) {
          if (e.key === 'ArrowRight') { moveApp(1); e.preventDefault(); }
          else if (e.key === 'ArrowLeft') { moveApp(-1); e.preventDefault(); }
          else if (e.key === 'ArrowDown') { switchToCircle(0); e.preventDefault(); }
          else if (e.key === 'Backspace') { deleteSelectedApp(); e.preventDefault(); }
          else if (e.key.toLowerCase() === 'x') { deleteSelectedApp(); e.preventDefault(); }
        } else {
          // hold-mode active: arrow keys change target position (move selection)
          if (e.key === 'ArrowRight') { moveApp(1); e.preventDefault(); }
          else if (e.key === 'ArrowLeft') { moveApp(-1); e.preventDefault(); }
          else if (e.key === 'ArrowUp') { switchToApps(); e.preventDefault(); }
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'Enter') {
        if (keyHoldTimer) {
          // released before threshold -> treat as tap (Ê±∫ÂÆö)
          clearTimeout(keyHoldTimer);
          keyHoldTimer = null;
          openSelected();
        } else if (holdMode.active && holdMode.initiatedBy === 'key') {
          // release after hold-mode -> commit
          endHoldModeCommit();
        }
        enterDown = false;
      }
    });

    /* ---------------- mouse click/long-press behavior for left-click "Ê±∫ÂÆö„Éõ„Éº„É´„Éâ" ----------------
       Note: pointer long-press already triggers swap-drag above.
       We will also allow left-click hold (on body) to be used as hold-mode (Â∑Æ„ÅóËæº„Åø) if the user clicks while selected.
       To avoid conflict, we consider long-press on an app starts pointer-swap-drag (handled in bind). For global left button (on selected item),
       we provide Enter-like hold behavior: mousedown on selected icon -> start timer for hold-mode; if released quickly -> open; if held -> hold-mode.
    */
    let pointerHoldState = { timer: null, activeForIndex: null };

    // attach mousedown/up on launcher to detect left-button holds on currently selected app
    launcher.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // only left
      const app = e.target.closest('.app');
      if (!app) return;
      const idx = apps().indexOf(app);
      if (idx < 0) return;
      // if this pointerdown was long-press handled by bindAppPointerHandlers -> pointer-swap-drag will take over.
      // But we still set a separate timer to start hold-mode if the user keeps holding (for decision-hold behavior).
      pointerHoldState.timer = setTimeout(() => {
        // enter hold-mode (decision-hold) for that index
        startHoldMode(idx, 'pointer');
        pointerHoldState.activeForIndex = idx;
        pointerHoldState.timer = null;
      }, HOLD_THRESHOLD);
    });

    window.addEventListener('mouseup', (e) => {
      if (e.button !== 0) return;
      if (pointerHoldState.timer) {
        // released before threshold: treat as click (Ê±∫ÂÆö)
        clearTimeout(pointerHoldState.timer);
        pointerHoldState.timer = null;
        // perform click behavior: if clicked selected -> open, else select
        const app = e.target.closest('.app');
        if (!app) return;
        const idx = apps().indexOf(app);
        if (idx === selectedIndex) openSelected(); else { selectedIndex = idx; updateSelectionUI(); }
      } else if (pointerHoldState.activeForIndex != null) {
        // released after hold-mode initiation by pointer -> commit hold-mode move if active
        if (holdMode.active && holdMode.initiatedBy === 'pointer') {
          endHoldModeCommit();
        } else {
          cancelHoldMode();
        }
        pointerHoldState.activeForIndex = null;
      }
    }, {passive:true});

    /* ---------------- click/dblclick handlers (ÈÄöÂ∏∏„ÇØ„É™„ÉÉ„ÇØ ‚Üí Ê±∫ÂÆö) ---------------- */
    // basic click handled earlier for add/delete etc. But ensure single-click open when clicking selected:
    launcher.addEventListener('click', (e) => {
      const app = e.target.closest('.app');
      if (!app) return;
      const idx = apps().indexOf(app);
      if (idx < 0) return;

      // delete button
      if (e.target.classList.contains('delete-btn')) {
        e.stopPropagation();
        const toDel = e.target.closest('.app');
        toDel.remove();
        if (selectedIndex >= apps().length) selectedIndex = apps().length - 1;
        updateSelectionUI();
        saveAppsToCookie();
        return;
      }

      // left-click: if same item -> open, else select
      if (idx === selectedIndex) {
        openSelected();
      } else {
        selectedIndex = idx;
        circleIndex = -1;
        updateSelectionUI();
      }
    });

    launcher.addEventListener('dblclick', (e) => {
      const app = e.target.closest('.app');
      if (!app) return;
      const idx = apps().indexOf(app);
      if (idx >= 0) {
        selectedIndex = idx;
        openSelected();
      }
    });

    /* ---------------- ‰∏ãÊÆµ„Éú„Çø„É≥„Éõ„Éê„Éº/„ÇØ„É™„ÉÉ„ÇØ ---------------- */
    circleBtns.forEach((btn, i) => {
      btn.addEventListener('pointerenter', (ev) => {
        if (ev.pointerType === 'mouse') { circleIndex = i; updateSelectionUI(); }
      }, {passive:true});
      btn.addEventListener('pointerdown', (ev) => { circleIndex = i; updateSelectionUI(); }, {passive:true});
    });

    document.getElementById('btn-settings').addEventListener('click', () => {
      try { window.open('chrome://settings/', '_blank'); } catch (e) { alert('„Åì„ÅÆ„Éñ„É©„Ç¶„Ç∂„Åß„ÅØÈñã„Åë„Åæ„Åõ„Çì„ÄÇ'); }
    });
    document.getElementById('btn-store').addEventListener('click', () => { window.open('https://www.amazon.co.jp/', '_blank'); });
    document.getElementById('btn-power').addEventListener('click', () => { alert('ÔΩºÔΩ¨ÔΩ≤ÔΩºÔΩ¨ÔΩ≤ÔΩºÔΩ¨ÔΩ∞ÔΩ≤'); });

    /* ---------------- keyboard navigation (Áü¢Âç∞Á≠â) „ÅØ‰∏ä„ÅßÂàÜÂ≤ê„Åï„Åõ„Å¶„ÅÑ„Çã ---------------- */

    /* ---------------- gamepad: A „ÅÆÈï∑Êäº„Åó„Åß hold-mode„ÄÅÁü≠Êäº„Åó„ÅßÊ±∫ÂÆö„ÄÅX„ÅßÂâäÈô§„ÄÅY„ÅßËøΩÂä† ---------------- */
    let gpButtonDownTime = {};
    function pollGamepad(){
      const gpList = navigator.getGamepads && navigator.getGamepads();
      const gp = gpList ? gpList[0] : null;
      if (gp) {
        const buttons = gp.buttons.map(b => !!b.pressed);
        const axes = gp.axes.slice(0,4);

        // D-Pad edge detect for immediate navigation
        if (buttons[15] && !gpPrevButtons[15]) { if (!holdMode.active) { moveApp(1); } else { moveApp(1); } } // right
        if (buttons[14] && !gpPrevButtons[14]) { if (!holdMode.active) { moveApp(-1); } else { moveApp(-1); } } // left
        if (buttons[13] && !gpPrevButtons[13]) { switchToCircle(0); } // down -> bottom
        if (buttons[12] && !gpPrevButtons[12]) { switchToApps(); } // up -> apps

        // Left stick horizontal (edge)
        if (axes[0] > 0.6 && gpPrevAxes[0] <= 0.6) { moveApp(1); }
        else if (axes[0] < -0.6 && gpPrevAxes[0] >= -0.6) { moveApp(-1); }
        // Left stick vertical (edge)
        if (axes[1] > 0.6 && gpPrevAxes[1] <= 0.6) { switchToCircle(0); }
        else if (axes[1] < -0.6 && gpPrevAxes[1] >= -0.6) { switchToApps(); }

        // Buttons behavior with hold detection for A (0)
        // Track down time
        if (buttons[0] && !gpPrevButtons[0]) { gpButtonDownTime['A'] = now(); } // down
        if (!buttons[0] && gpPrevButtons[0]) { // up
          const down = gpButtonDownTime['A'] || 0;
          const dur = now() - down;
          delete gpButtonDownTime['A'];
          if (dur < HOLD_THRESHOLD && !holdMode.active) {
            // short press -> Ê±∫ÂÆö
            openSelected();
          } else if (holdMode.active && holdMode.initiatedBy === 'gamepad') {
            // release after hold-mode -> commit
            endHoldModeCommit();
          } else {
            cancelHoldMode();
          }
        }
        // while held, if now - down >= HOLD_THRESHOLD and holdMode not active => start hold-mode
        if (buttons[0] && !holdMode.active && gpButtonDownTime['A'] && (now() - gpButtonDownTime['A'] >= HOLD_THRESHOLD)) {
          startHoldMode(selectedIndex, 'gamepad');
        }

        // X short press -> delete
        if (buttons[2] && !gpPrevButtons[2]) { deleteSelectedApp(); } // X

        // Y short press -> add (they wanted Y = ËøΩÂä†). If long-press desired, could add but keep short press.
        if (buttons[3] && !gpPrevButtons[3]) { openAddDialog(); }

        // save prev
        gpPrevButtons = buttons;
        gpPrevAxes[0] = axes[0];
        gpPrevAxes[1] = axes[1];
      }
      requestAnimationFrame(pollGamepad);
    }
    pollGamepad();

    /* ---------------- ÊôÇÂàª„Éª„Éê„ÉÉ„ÉÜ„É™„Éº ---------------- */
    function updateTime(){ document.getElementById('time').textContent = new Date().toLocaleTimeString('ja-JP',{hour:'2-digit',minute:'2-digit'}); }
    setInterval(updateTime,1000); updateTime();
    if (navigator.getBattery) {
      navigator.getBattery().then(b => {
        function upd(){ document.getElementById('battery').textContent = 'üîã ' + Math.round(b.level*100) + '%'; }
        upd();
        b.addEventListener('levelchange', upd);
      });
    }

    /* ---------------- ÂàùÊúüÂåñ ---------------- */
    const restored = loadAppsFromCookie();
    apps().forEach(bindAppPointerHandlers);
    updateSelectionUI();
    bindAppPointerHandlers(addAppEl);

    // ensure keyboard/resize behaviors
    window.addEventListener('resize', ()=>{ setTimeout(()=>scrollSelectedIntoView(), 80); });

    /* ---------------- ‰øùÂ≠ò„Çø„Ç§„Éü„É≥„Ç∞Ê≥®ÊÑè ---------------- */
    // saveAppsToCookie() „ÅØ
    // „ÉªÂâäÈô§ÊôÇ„ÄÅËøΩÂä†ÊôÇ„ÄÅÈï∑Êäº„Åó„Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫ÜÊôÇÔºàÈö£ÂÖ•„ÇåÊõø„ÅàÔºâ„ÄÅ„Éõ„Éº„É´„ÉâÂ∑ÆËæº„ÅÆ„Ç≥„Éü„ÉÉ„ÉàÊôÇ „Å´Âëº„Çì„Åß„ÅÑ„Çã
  </script>
</body>
</html>
